<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match Recordings Playback</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .match-group {
            border: 2px solid #374151;
            border-radius: 8px;
            margin-bottom: 16px;
            overflow: hidden;
        }
        .match-group.active {
            border-color: #3b82f6;
        }
        .match-header {
            background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .match-header:hover {
            background: linear-gradient(135deg, #374151 0%, #1f2937 100%);
        }
        .camera-list {
            background: #0f172a;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        .camera-list.expanded {
            max-height: 400px;
        }
        .camera-item {
            padding: 8px 16px;
            border-bottom: 1px solid #1e293b;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .camera-item:hover {
            background: #1e293b;
        }
        .camera-item.active {
            background: #1e40af;
        }
        .filter-section {
            background: #1f2937;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .match-type-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 9999px;
            font-weight: bold;
        }
        .type-practice { background-color: #059669; color: white; }
        .type-quals { background-color: #dc2626; color: white; }
        .type-semis { background-color: #ea580c; color: white; }
        .type-finals { background-color: #7c3aed; color: white; }
    </style>
</head>
<body class="bg-gray-800 text-white p-8">

    <div class="max-w-6xl mx-auto">
        <div class="flex justify-between items-center mb-8">
            <h1 class="text-4xl font-bold">Match Recording Playback</h1>
            <a href="/" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-white">‚Üê Back to Live View</a>
        </div>

        <!-- Filter Section -->
        <div class="filter-section">
            <h3 class="text-lg font-bold mb-4">Filter Recordings</h3>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div>
                    <label for="matchFilter" class="block text-sm font-medium mb-2">Match Number:</label>
                    <input type="number" id="matchFilter" placeholder="e.g., 1" class="w-full p-2 bg-gray-700 border border-gray-600 rounded">
                </div>
                <div>
                    <label for="matchTypeFilter" class="block text-sm font-medium mb-2">Match Type:</label>
                    <select id="matchTypeFilter" class="w-full p-2 bg-gray-700 border border-gray-600 rounded">
                        <option value="">All Types</option>
                        <option value="P">Practice</option>
                        <option value="Q">Qualification</option>
                        <option value="SD">Semifinals</option>
                        <option value="F">Finals</option>
                    </select>
                </div>
                <div>
                    <label for="cameraFilter" class="block text-sm font-medium mb-2">Camera:</label>
                    <select id="cameraFilter" class="w-full p-2 bg-gray-700 border border-gray-600 rounded">
                        <option value="">All Cameras</option>
                    </select>
                </div>
                <div class="flex items-end">
                    <button id="clearFilters" class="w-full bg-red-600 hover:bg-red-700 px-4 py-2 rounded">Clear Filters</button>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Video Player -->
            <div class="lg:col-span-2">
                <div class="bg-black rounded-lg shadow-lg overflow-hidden">
                    <video id="videoPlayer" class="w-full h-full" controls autoplay>
                        Your browser does not support the video tag.
                    </video>
                </div>
                
                <!-- Video Info -->
                <div id="videoInfo" class="mt-4 p-4 bg-gray-900 rounded-lg">
                    <h3 class="text-lg font-bold text-cyan-400">No video selected</h3>
                    <p class="text-gray-400">Select a recording from the playlist to begin playback</p>
                </div>
            </div>

            <!-- Match Groups Playlist -->
            <div class="bg-gray-900/50 p-4 rounded-lg">
                <h2 class="text-xl font-bold mb-4">Match Recordings</h2>
                <div id="matchGroups" class="h-96 overflow-y-auto">
                    <!-- Match groups will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        const videoPlayer = document.getElementById('videoPlayer');
        const videoInfo = document.getElementById('videoInfo');
        const matchGroups = document.getElementById('matchGroups');
        const matchFilter = document.getElementById('matchFilter');
        const matchTypeFilter = document.getElementById('matchTypeFilter');
        const cameraFilter = document.getElementById('cameraFilter');
        const clearFilters = document.getElementById('clearFilters');

        let allRecordings = [];
        let groupedRecordings = {};
        let currentActiveGroup = null;

        async function loadRecordings() {
            try {
                const response = await fetch('/api/recordings');
                allRecordings = await response.json();

                if (allRecordings.length === 0) {
                    matchGroups.innerHTML = '<div class="text-gray-400 text-center p-4">No recordings found.</div>';
                    return;
                }

                populateCameraFilter();
                groupRecordings();
                renderMatchGroups();

            } catch (error) {
                console.error('Failed to load recordings:', error);
                matchGroups.innerHTML = '<div class="text-red-400 text-center p-4">Error loading recordings.</div>';
            }
        }

        function populateCameraFilter() {
            const cameras = new Set();
            allRecordings.forEach(file => {
                // Parse filename format: P1_xs-max-1_2025-08-05T21-24-58.mp4
                const match = file.match(/^([PQF]|SD)(\d+)_(.+?)_(.+)\.mp4$/);
                if (match) {
                    const camera = match[3]; // xs-max-1
                    cameras.add(camera);
                }
            });

            cameraFilter.innerHTML = '<option value="">All Cameras</option>';
            Array.from(cameras).sort().forEach(camera => {
                const option = document.createElement('option');
                option.value = camera;
                option.textContent = camera;
                cameraFilter.appendChild(option);
            });
        }

        function parseFilename(filename) {
            // Parse format: P1_xs-max-1_2025-08-05T21-24-58.mp4
            const match = filename.match(/^([PQF]|SD)(\d+)_(.+?)_(.+)\.mp4$/);
            if (match) {
                return {
                    matchType: match[1],     // P, Q, SD, F
                    matchNumber: parseInt(match[2]), // 1, 2, 3, etc.
                    camera: match[3],       // xs-max-1
                    timestamp: match[4]     // 2025-08-05T21-24-58
                };
            }
            return null;
        }

        function getMatchTypeDisplay(type) {
            const typeMap = {
                'P': 'Practice',
                'Q': 'Qualification', 
                'SD': 'Semifinals',
                'F': 'Finals'
            };
            return typeMap[type] || type;
        }

        function getMatchTypeBadgeClass(type) {
            const classMap = {
                'P': 'type-practice',
                'Q': 'type-quals',
                'SD': 'type-semis', 
                'F': 'type-finals'
            };
            return classMap[type] || 'type-practice';
        }

        function groupRecordings() {
            groupedRecordings = {};
            
            allRecordings.forEach(file => {
                const parsed = parseFilename(file);
                
                if (parsed) {
                    const { matchType, matchNumber, camera, timestamp } = parsed;
                    const groupKey = `${matchType}${matchNumber}`;
                    
                    if (!groupedRecordings[groupKey]) {
                        groupedRecordings[groupKey] = {
                            matchNumber,
                            matchType,
                            cameras: {},
                            timestamp
                        };
                    }
                    
                    groupedRecordings[groupKey].cameras[camera] = file;
                }
            });
        }

        function renderMatchGroups() {
            const filteredGroups = applyFilters();
            matchGroups.innerHTML = '';

            if (Object.keys(filteredGroups).length === 0) {
                matchGroups.innerHTML = '<div class="text-gray-400 text-center p-4">No matches found with current filters.</div>';
                return;
            }

            // Sort by match type then by match number (descending)
            Object.values(filteredGroups)
                .sort((a, b) => {
                    if (a.matchType !== b.matchType) {
                        const typeOrder = { 'P': 0, 'Q': 1, 'SD': 2, 'F': 3 };
                        return (typeOrder[a.matchType] || 999) - (typeOrder[b.matchType] || 999);
                    }
                    return b.matchNumber - a.matchNumber;
                })
                .forEach(matchGroup => {
                    const groupElement = createMatchGroupElement(matchGroup);
                    matchGroups.appendChild(groupElement);
                });

            // Auto-expand and play first match
            const firstGroup = Object.values(filteredGroups)[0];
            if (firstGroup) {
                const groupKey = `${firstGroup.matchType}${firstGroup.matchNumber}`;
                expandMatchGroup(groupKey);
                const firstCamera = Object.keys(firstGroup.cameras)[0];
                if (firstCamera) {
                    playVideo(firstGroup.cameras[firstCamera], firstGroup.matchNumber, firstGroup.matchType, firstCamera);
                }
            }
        }

        function createMatchGroupElement(matchGroup) {
            const groupKey = `${matchGroup.matchType}${matchGroup.matchNumber}`;
            const groupDiv = document.createElement('div');
            groupDiv.className = 'match-group';
            groupDiv.id = `match-group-${groupKey}`;

            const header = document.createElement('div');
            header.className = 'match-header';
            
            const typeDisplay = getMatchTypeDisplay(matchGroup.matchType);
            const badgeClass = getMatchTypeBadgeClass(matchGroup.matchType);
            
            header.innerHTML = `
                <div>
                    <h3 class="font-bold text-lg flex items-center gap-2">
                        ${matchGroup.matchType}${matchGroup.matchNumber}
                        <span class="match-type-badge ${badgeClass}">${typeDisplay}</span>
                    </h3>
                    <p class="text-sm text-gray-400">${Object.keys(matchGroup.cameras).length} camera(s)</p>
                </div>
                <svg class="w-5 h-5 transform transition-transform" id="arrow-${groupKey}" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
            `;

            const cameraList = document.createElement('div');
            cameraList.className = 'camera-list';
            cameraList.id = `cameras-${groupKey}`;

            Object.entries(matchGroup.cameras).forEach(([camera, filename]) => {
                const cameraItem = document.createElement('div');
                cameraItem.className = 'camera-item';
                cameraItem.innerHTML = `
                    <div>
                        <span class="font-medium">${camera}</span>
                        <div class="text-xs text-gray-400">${filename}</div>
                    </div>
                    <button class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-xs">Play</button>
                `;
                
                cameraItem.onclick = () => playVideo(filename, matchGroup.matchNumber, matchGroup.matchType, camera);
                cameraList.appendChild(cameraItem);
            });

            header.onclick = () => toggleMatchGroup(groupKey);
            
            groupDiv.appendChild(header);
            groupDiv.appendChild(cameraList);
            
            return groupDiv;
        }

        function toggleMatchGroup(groupKey) {
            const cameraList = document.getElementById(`cameras-${groupKey}`);
            const arrow = document.getElementById(`arrow-${groupKey}`);
            const group = document.getElementById(`match-group-${groupKey}`);
            
            if (cameraList.classList.contains('expanded')) {
                cameraList.classList.remove('expanded');
                arrow.style.transform = 'rotate(0deg)';
                group.classList.remove('active');
            } else {
                // Close other groups
                document.querySelectorAll('.camera-list.expanded').forEach(list => {
                    list.classList.remove('expanded');
                });
                document.querySelectorAll('.match-group.active').forEach(g => {
                    g.classList.remove('active');
                });
                document.querySelectorAll('[id^="arrow-"]').forEach(a => {
                    a.style.transform = 'rotate(0deg)';
                });
                
                // Open this group
                cameraList.classList.add('expanded');
                arrow.style.transform = 'rotate(180deg)';
                group.classList.add('active');
                currentActiveGroup = groupKey;
            }
        }

        function expandMatchGroup(groupKey) {
            const cameraList = document.getElementById(`cameras-${groupKey}`);
            const arrow = document.getElementById(`arrow-${groupKey}`);
            const group = document.getElementById(`match-group-${groupKey}`);
            
            if (cameraList && arrow && group) {
                cameraList.classList.add('expanded');
                arrow.style.transform = 'rotate(180deg)';
                group.classList.add('active');
                currentActiveGroup = groupKey;
            }
        }

        function playVideo(filename, matchNumber, matchType, camera) {
            videoPlayer.src = `/recordings/${filename}`;
            videoPlayer.load();
            videoPlayer.play();

            const typeDisplay = getMatchTypeDisplay(matchType);
            
            // Update video info
            videoInfo.innerHTML = `
                <h3 class="text-lg font-bold text-cyan-400">${matchType}${matchNumber} (${typeDisplay}) - ${camera}</h3>
                <p class="text-gray-400">Playing: ${filename}</p>
                <div class="mt-2 text-sm text-gray-500">
                    <span>File size: Loading...</span> | 
                    <span>Duration: Loading...</span>
                </div>
            `;

            // Highlight active camera
            document.querySelectorAll('.camera-item').forEach(item => {
                item.classList.remove('active');
            });
            event.currentTarget.classList.add('active');

            // Load additional file info
            loadVideoMetadata(filename);
        }

        function loadVideoMetadata(filename) {
            fetch(`/api/video-info/${filename}`)
                .then(response => response.json())
                .then(data => {
                    const sizeInMB = (data.size / (1024 * 1024)).toFixed(2);
                    videoInfo.querySelector('.text-gray-500').innerHTML = `
                        <span>File size: ${sizeInMB} MB</span> | 
                        <span>Duration: ${formatDuration(videoPlayer.duration)}</span>
                    `;
                })
                .catch(() => {
                    // Fallback to basic info
                    videoInfo.querySelector('.text-gray-500').innerHTML = `
                        <span>File info unavailable</span>
                    `;
                });
        }

        function formatDuration(seconds) {
            if (isNaN(seconds)) return 'Unknown';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function applyFilters() {
            let filtered = { ...groupedRecordings };

            if (matchFilter.value) {
                const matchNum = parseInt(matchFilter.value);
                filtered = Object.fromEntries(
                    Object.entries(filtered).filter(([key, group]) => group.matchNumber === matchNum)
                );
            }

            if (matchTypeFilter.value) {
                filtered = Object.fromEntries(
                    Object.entries(filtered).filter(([key, group]) => group.matchType === matchTypeFilter.value)
                );
            }

            if (cameraFilter.value) {
                Object.keys(filtered).forEach(key => {
                    const group = filtered[key];
                    const filteredCameras = Object.fromEntries(
                        Object.entries(group.cameras).filter(([camera, filename]) => camera === cameraFilter.value)
                    );
                    if (Object.keys(filteredCameras).length === 0) {
                        delete filtered[key];
                    } else {
                        filtered[key].cameras = filteredCameras;
                    }
                });
            }

            return filtered;
        }

        // Event listeners for filters
        matchFilter.addEventListener('input', renderMatchGroups);
        matchTypeFilter.addEventListener('change', renderMatchGroups);
        cameraFilter.addEventListener('change', renderMatchGroups);
        clearFilters.addEventListener('click', () => {
            matchFilter.value = '';
            matchTypeFilter.value = '';
            cameraFilter.value = '';
            renderMatchGroups();
        });

        // Load recordings when the page opens
        loadRecordings();
    </script>

</body>
</html>